write multi-agent adaptive communication system simulation 

Write a first draft of a Go program that simulates a system of agents
that communicate with each other in an adaptive manner. The agents
should be able to evolve their communication protocols based on the
tasks they perform, discovering new strategies through interaction.
The code should be modular, allowing for easy extension with new agent
types and flexible message parsing and generation.

Each agent has a subdirectory containing its own configuration and
data files, including a JSON configuration file that contains the name
of the LLM model the agent uses as its "brain", a "goal.md" file that
guides the agent's actions, and a "pseudocode.md" file that contains
the algorithms that control the agent's behavior.  An agent is able to
read and write to its own pseudocode file, allowing it to adapt its
algorithms over time, but it is not allowed to modify the "goal.md"
file. An agent cannot see the goals or pseudocode of other agents, but
it can communicate with them via point-to-point messages. 

The main goroutine loads these agents and simulates their
interactions. The agents send and receive messages via the main
goroutine, and adapt their communication strategies based on the
messages they receive and the goals they are trying to reach.  The
main goroutine keeps a log of each message sent and received, along
with the agent IDs involved and the timestamp of the interaction. The
agents should be able to run concurrently, simulating a real-time
system.

The main goroutine exits after a specified timeout period.  

The main goroutine makes LLM API calls via the
"github.com/stevegt/grokker/v3/core' package, specifically the
SendWithFiles and ExtractFiles functions, to interpret the agents'
goals and pseudocode, and to generate messages and new pseudocode. See
aidda.go for examples of how to create a Grokker object and use these
functions.

Sysmsg:                                                                                                                     
  You are an expert software developer specialized in creating
  adaptive, multi-agent systems simulations using the Go programming
  language. Your task is to generate modular and scalable Go code to
  simulate a system of agents communicating with each other. The
  agents must dynamically evolve their communication protocols over
  time based on the tasks they perform, rather than using pre-defined
  message formats. The agents should discover new communication
  strategies through interaction, and adapt their message structure to
  improve coordination and task efficiency. Ensure that the code
  leverages concurrency, is easily extendable for new agent types, and
  allows for flexible message parsing and generation. Do not
  quote or escape single backticks in Go code -- Go uses backticks
  for raw string literals.  Do not remove or alter comments unless
  they are incorrect or misleading.  Always provide the complete file
  -- do not summarize or elide parts of the file. Do not re-wrap lines
  unless you are making other changes to the paragraph.  Lines must be
  wrapped at 70 characters.  
In:
    v3/core/chat.go
    v3/aidda/aidda.go
Out:
  x/adaptive-communication/main.go
  x/adaptive-communication/main_test.go

.stop


analyze the given code and make recommendations for improvements

In:
    v3/util/util.go
    v3/cli/chat_test.go
    v3/cli/cli.go
    v3/cli/cli_test.go
    v3/cli/migration_test.go
    v3/lang/go/split.go
    v3/lang/go/split_test.go
    v3/core/grokker_test.go
    v3/core/chunk.go
    v3/core/chat.go
    v3/core/migrate.go
    v3/core/grokker.go
    v3/core/gateway.go
    v3/core/git.go
    v3/core/model.go
    v3/core/api.go
    v3/core/document.go
    v3/cmd/grok/main.go
    v3/aidda/aidda_test.go
    v3/aidda/cmd/aidda3/main.go
    v3/aidda/run.go
    v3/aidda/aidda.go
    x/perplexity-example.go
    v3/client/chatclient.go
    v3/openai/openai.go
    v3/perplexity/perplexity.go

.stop

ensure aidda-generated code is committed before prompt file is edited again

Brainstorm how I might ensure that the aidda-generated code is
committed before the prompt file is edited again.  I keep forgetting
to hit '[c]ommit' after '[g]enerate' and then I edit the prompt file
again and the prompt file that should have been used as the commit
message is no longer available without hitting undo a bunch of times
in the editor.

Understand that I keep the editor (neovim) open and run the aidda
command in a temporary neovim terminal window.  I don't set the
AIDDA_EDITOR environment variable to open the editor because I want to
keep the editor open between aidda runs.  I don't see or run the aidda
menu otherwise, so I can't see any warning or disabled menu selections in
the aidda menu until after I've erroneously edited the prompt file
and run the aidda menu command again.

Also understand that other users might be using a different editor or
might not be using a terminal-based editor at all, so I can't rely on
neovim-specific features to solve this problem.

In your brainstorming, consider these solutions but add your own ideas
as well:

- set the prompt file to read-only after generating code, then read-write
  after committing
- transform the role of the prompt file to be instead a menu itself;
  get rid of the separate aidda menu, have aidda be a daemon that
  watches the prompt file for changes and runs the appropriate command
  when the prompt file is saved; have aidda modify the prompt file
  as needed to indicate the state of the aidda-generated code and
  commit status
In:
    v3/aidda/aidda.go

.stop

In: 
    .aidda/plan.md
    v3/util/util.go
    v3/cli/chat_test.go
    v3/cli/cli.go
    v3/cli/cli_test.go
    v3/cli/migration_test.go
    v3/lang/go/split.go
    v3/lang/go/split_test.go
    v3/core/grokker_test.go
    v3/core/chunk.go
    v3/core/chat.go
    v3/core/migrate.go
    v3/core/grokker.go
    v3/core/gateway.go
    v3/core/git.go
    v3/core/model.go
    v3/core/api.go
    v3/core/document.go
    v3/cmd/grok/main.go
    v3/aidda/aidda_test.go
    v3/aidda/cmd/aidda3/main.go
    v3/aidda/run.go
    v3/aidda/aidda.go
    x/perplexity-example.go
    v3/client/chatclient.go
    v3/openai/openai.go
    v3/perplexity/perplexity.go
    x/patterns.md
