Below is one example of converting the output‐file “extraction” and “inclusion” routines from looking for our old “File:” header plus code‐fence output to instead use our new custom delimited format. In our new scheme every file block will be embedded as follows:

  ---FILE-START filename="exact_filename.ext"---
  [content here]
  ---FILE-END filename="exact_filename.ext"---

In the code below we change two functions in core/chat.go. First we update OutfilesRegex() so that it returns a regex that (using dot‑all mode) finds a file block where the only capturing group is the file’s content. Second, we update IncludeFiles() so that when the input files are included in the prompt the text is wrapped in our new delimiters.

Modify the file /home/stevegt/lab/grokker/v3/core/chat.go as follows (only the functions we update are shown):

--------------------------------------------------
package core

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
	"time"

	. "github.com/stevegt/goadapt"
	"github.com/stevegt/grokker/v3/client"
	"github.com/stevegt/grokker/v3/util"
)

// … existing types and functions …

// OutfilesRegex now returns a regex that looks for file blocks using custom delimiters.
// The regex uses dot‑all mode (?s) so that the file content (captured in group 1)
// spans multiple lines.
func OutfilesRegex(files []FileLang) string {
	// This pattern matches:
	// ---FILE-START filename="(any non-quote characters)"---
	//    (capture any text non-greedily)
	// ---FILE-END filename="(same filename)"---
	// (We ignore the filename inside the delimiters here.)
	return `(?s)---FILE-START filename="[^"]+"---\s*(.*?)\s*---FILE-END filename="[^"]+"---`
}

// IncludeFiles returns a prompt fragment with each input file embedded using our new custom delimiters.
// Instead of the old “File:” header plus code fence format, we now use:
// ---FILE-START filename="exact_filename.ext"---
// <file text>
// ---FILE-END filename="exact_filename.ext"---
func IncludeFiles(files []string) (prompt string, err error) {
	for _, fn := range files {
		buf, err := ioutil.ReadFile(fn)
		if err != nil {
			return "", fmt.Errorf("could not read file '%s': %s", fn, err)
		}
		txt := string(buf)
		// ensure that the file ends with a newline
		if !strings.HasSuffix(txt, "\n") {
			txt += "\n"
		}
		// Use our new delimiters:
		prompt += fmt.Sprintf("\n---FILE-START filename=\"%s\"---\n%s---FILE-END filename=\"%s\"---\n", fn, txt, fn)
	}
	return prompt, nil
}

// ExtractFiles (which uses OutfilesRegex) no longer needs to change,
// so it will now extract the file content from group 1 of our new regex.
func ExtractFiles(outfiles []FileLang, resp string, dryrun, extractToStdout bool) (err error) {
	defer Return(&err)
	// Loop over each expected outfile
	for _, fileLang := range outfiles {
		// Use our new regex (ignore fileLang details in the regex for now)
		re := regexp.MustCompile(OutfilesRegex(nil))
		match := re.FindStringSubmatch(resp)
		if len(match) == 0 {
			Fpf(os.Stderr, "Warning: file not found in the response for %q\nregex was: '%s'\n", fileLang.File, re.String())
			Fpf(os.Stderr, "Response was:\n%s\n", resp)
			continue
		}
		// match[1] now holds the file content.
		if !dryrun {
			if extractToStdout {
				_, err = Pf("%s", match[1])
				Ck(err)
			} else {
				err = os.WriteFile(fileLang.File, []byte(match[1]), 0644)
				Ck(err)
			}
		}
	}
	return
}

// … remainder of file unchanged …
--------------------------------------------------

Explanation of changes:
1. OutfilesRegex now returns a much simpler regex that (in dot‑all mode) looks for the new start and end markers with a non‑greedy capture of the file content.
2. IncludeFiles now formats each file block using our new delimiters rather than a “File:” header plus markdown code fence.

With these changes the code that extracts output files from an LLM response (in cli/cli.go) will now compile the new regex and extract group 1 (the file content) for writing, and any function that embeds files (for example in a prompt) will wrap the file text in the new delimiters.

Compile and run your tests (and try the “chat” subcommand when –o is used) to verify that the output files are now written and later extracted using the new delimiters.

This example meets the requirements without “hallucinating” any libraries or functions that do not exist.