File: /home/stevegt/lab/grokker/.aidda/plan.md
```markdown
# Integration Plan Update: Client Initialization and Perplexity.ai Provider Refactoring

This document outlines two main changes:

1. **Client Initialization Based on Model Configuration:**  
   The existing `initClients()` function will be refactored into a factory‑style function. At startup the Grokker core will examine the model configuration – now including a new field `Provider` – and decide which API client to initialize. For example:  
   - For `"openai"` models, the OpenAI client is constructed as before.
   - For `"perplexity"` models, a new Perplexity.ai client will be instantiated.
   
   This change enables the code to remain provider‑agnostic and easily support multiple LLM backends. All downstream APIs (chat completions, embeddings, etc.) will invoke methods on the active client (which satisfies a common interface, e.g. `ChatProvider`).

2. **Refactoring the Perplexity.ai Provider Implementation:**  
   The file `v3/perplexity/perplexity.go` will implement the Perplexity.ai API client with simplified identifiers – removing the "perplexity" prefix from all names. For example:
   - The client type is now defined as a plain `Client` instead of `PerplexityClient`.
   - The constructor is `NewClient()` instead of `NewPerplexityClient()`.
   - Other identifiers (such as request/response types and associated fields) are renamed generically (e.g. `Request`, `Response`, `Message`, `Choice`).
   
   The new client implementation will:
   - Read the `PERPLEXITY_API_KEY` environment variable.
   - Use the Perplexity.ai API endpoint (`https://api.perplexity.ai/chat/completions`) with a default model (for instance, `"sonar-deep-research"`).
   - Accept a system message and a slice of chat messages, perform an HTTP POST to the API, parse the JSON response, and return the chat response from the first choice.

By implementing these changes, Grokker will initialize and choose between multiple providers at runtime based on the model configuration while maintaining a unified interface for chat completion and embedding API calls.
```
EOF_/home/stevegt/lab/grokker/.aidda/plan.md

File: /home/stevegt/lab/grokker/v3/perplexity/perplexity.go
```go
package core

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

// Client encapsulates the API client for Perplexity.ai.
type Client struct {
	APIKey   string
	Endpoint string
}

// NewClient creates a new Client instance.
// It reads the PERPLEXITY_API_KEY from the environment and sets the API endpoint.
func NewClient() *Client {
	key := os.Getenv("PERPLEXITY_API_KEY")
	if key == "" {
		fmt.Fprintln(os.Stderr, "Warning: PERPLEXITY_API_KEY environment variable not set")
	}
	return &Client{
		APIKey:   key,
		Endpoint: "https://api.perplexity.ai/chat/completions",
	}
}

// Request defines the request payload sent to Perplexity.ai.
type Request struct {
	Model    string    `json:"model"`
	Messages []Message `json:"messages"`
}

// Message represents a single message in the chat conversation.
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// Response defines the structure of the response from Perplexity.ai.
type Response struct {
	Citations []string `json:"citations"`
	Choices   []Choice `json:"choices"`
}

// Choice holds a single generated chat choice.
type Choice struct {
	FinishReason string  `json:"finish_reason"`
	Role         string  `json:"role"`
	Message      Message `json:"message"`
}

// CompleteChat implements the ChatProvider interface for Client.
// It sends the system message along with the chat history to the Perplexity.ai API,
// and returns the content of the first choice in the response.
func (c *Client) CompleteChat(sysmsg string, messages []ChatMsg) (string, error) {
	// Prepare the request payload.
	reqPayload := Request{
		Model: "sonar-deep-research", // This can be adjusted or made configurable.
		Messages: []Message{
			{
				Role:    "system",
				Content: sysmsg,
			},
		},
	}

	// Convert ChatMsg (from Grokker) to Message for Perplexity.ai.
	for _, m := range messages {
		// Perplexity.ai prefers lowercase role names.
		reqPayload.Messages = append(reqPayload.Messages, Message{
			Role:    strings.ToLower(m.Role),
			Content: m.Txt,
		})
	}

	// Marshal the request payload.
	payloadBytes, err := json.Marshal(reqPayload)
	if err != nil {
		return "", err
	}

	// Create the HTTP request.
	req, err := http.NewRequest("POST", c.Endpoint, strings.NewReader(string(payloadBytes)))
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", c.APIKey))

	// Execute the HTTP request.
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Check for non-200 status codes.
	if resp.StatusCode != http.StatusOK {
		body, _ := ioutil.ReadAll(resp.Body)
		return "", fmt.Errorf("Perplexity API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Read and unmarshal the response.
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var response Response
	if err := json.Unmarshal(respBytes, &response); err != nil {
		return "", err
	}

	if len(response.Choices) == 0 {
		return "", fmt.Errorf("no choices in Perplexity response")
	}

	// Return the content of the first choice.
	return response.Choices[0].Message.Content, nil
}
```
EOF_/home/stevegt/lab/grokker/v3/perplexity/perplexity.go