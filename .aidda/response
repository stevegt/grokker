<think>
Looking at the code and the user's request, I need to replace the ohcount dependency with Go code using the go-enry library. Let me examine what the current code does:

1. The `getFileLanguages` function currently runs `ohcount -d <root>` as an external process
2. It parses the tab-delimited output where each line contains language and file path  
3. It handles "(null)" responses by falling back to MIME type detection
4. It returns a map of file paths to programming languages

Based on the search results, go-enry is the right library to use. From the search results, I can see:

1. go-enry provides functions like `enry.GetLanguage(filename string, content []byte) (language string)`
2. It's a port of GitHub's linguist to Go with 2x performance improvement
3. It uses multiple strategies: modeline, filename, shebang, extension, content, classifier
4. The library is available at `github.com/go-enry/go-enry/v2`

I need to:
1. Add the go-enry import
2. Replace the `getFileLanguages` function to use go-enry instead of ohcount
3. Use `filepath.Walk` to traverse the directory tree
4. For each file, read its content and call `enry.GetLanguage`
5. Keep the MIME type fallback for when go-enry can't determine the language

Let me implement this:

```go
import (
    "github.com/go-enry/go-enry/v2"
)

func getFileLanguages(root string) (map[string]string, error) {
    fileLangMap := make(map[string]string)
    
    walkFn := func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return fmt.Errorf("failed to access file %s: %v", path, err)
        }
        if info.IsDir() {
            return nil // skip directories
        }

        // Read file content
        content, err := ioutil.ReadFile(path)
        if err != nil {
            log.Printf("Failed to read file %s: %v", path, err)
            return nil // continue processing other files
        }

        // Detect language using go-enry's intelligent method
        language := enry.GetLanguage(path, content)
        
        if language == "" {
            // Fallback to MIME type detection when go-enry fails
            mtype, err := mimetype.DetectFile(

I'll continue processing the file detection logic, focusing on handling cases where language detection might fail and ensuring robust file traversal.

The detection mechanism will check for plain text files and skip binary or non-text content. This approach ensures efficient processing of relevant files while gracefully handling different file types.

I'll verify the import path for go-enry and ensure comprehensive language and file type detection across the file system walk.
</think>

Looking at your code and the research on go-enry, I'll replace the ohcount dependency with the go-enry library. Based on the search results, go-enry is the ideal replacement - it's a Go port of GitHub's linguist with 2x performance improvement and comprehensive language detection capabilities.

---FILE-START filename="/home/stevegt/lab/grokker/x/tokencount/main.go"---
package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/gabriel-vasile/mimetype"
	"github.com/go-enry/go-enry/v2"
	. "github.com/stevegt/goadapt"
	"github.com/stevegt/grokker/v3/core"
)

func main() {
	// Define and parse command-line flags
	showIndividual := flag.Bool("i", false, "Show individual token counts for each file")
	listFiles := flag.Bool("l", false, "List all countable files")
	flag.Parse()

	// Determine the directories to process
	directories := flag.Args()
	if len(directories) == 0 {
		directories = []string{"."}
	}

	fileLangMap := make(map[string]string)
	// Process each directory and merge file language mappings
	for _, dir := range directories {
		mapping, err := getFileLanguages(dir)
		// mapping, err := getMimeTypes(dir)
		if err != nil {
			log.Fatalf("Error getting file languages from directory %s: %v", dir, err)
		}
		for file, lang := range mapping {
			fileLangMap[file] = lang
		}
	}

	// If -l flag is set, list all countable files and exit
	if *listFiles {
		for file := range fileLangMap {
			fmt.Println(file)
		}
		os.Exit(0)
	}

	langCounts := make(map[string]int)
	langFileCounts := make(map[string]int)
	totalTokens := 0
	totalFiles := 0

	// Initialize Tokenizer
	var grok *core.Grokker
	err := core.InitTokenizer()
	Ck(err)

	// Prepare slice for individual file stats if -i flag is set
	type fileStat struct {
		Language string
		Tokens   int
		File     string
	}
	var individualStats []fileStat

	// Count tokens and files in each language
	for path, lang := range fileLangMap {
		tokens, err := countTokens(grok, path)
		if err != nil {
			log.Printf("Failed to count tokens in %s: %v", path, err)
			continue
		}
		langCounts[lang] += tokens
		langFileCounts[lang]++
		totalTokens += tokens
		totalFiles++

		individualStats = append(individualStats, fileStat{
			Language: lang,
			Tokens:   tokens,
			File:     path,
		})
	}

	if *showIndividual {
		// Sort individual stats by token count in descending order
		sort.Slice(individualStats, func(i, j int) bool {
			return individualStats[i].Tokens > individualStats[j].Tokens
		})

		// Print header
		fmt.Printf("%-20s  %-7s  %-50s\n", "Language", "Tokens", "File")
		fmt.Printf("%-20s  %-7s  %-50s\n", strings.Repeat("-", 20), strings.Repeat("-", 7), strings.Repeat("-", 50))

		// Print each file's stats
		for _, stat := range individualStats {
			fmt.Printf("%-20s  %7d  %-50s\n", stat.Language, stat.Tokens, stat.File)
		}

		// Print footer
		fmt.Printf("%-20s  %-7s  %-50s\n", strings.Repeat("-", 20), strings.Repeat("-", 7), strings.Repeat("-", 50))
		fmt.Printf("%-20s  %7d  %-50s\n", "Total", totalTokens, "All Files")
	} else {
		// Prepare a slice for sorting languages
		type langStat struct {
			Language string
			Files    int
			Tokens   int
		}

		var stats []langStat
		for lang, count := range langCounts {
			stats = append(stats, langStat{
				Language: lang,
				Files:    langFileCounts[lang],
				Tokens:   count,
			})
		}

		// Sort by token count, highest first
		sort.Slice(stats, func(i, j int) bool {
			return stats[i].Tokens > stats[j].Tokens
		})

		// Report totals by language in columnar format
		fmt.Printf("%-16s  %-5s  %-9s\n", "Language", "Files", "Tokens")
		fmt.Printf("----------------  -----  ---------\n")
		for _, stat := range stats {
			fmt.Printf("%-16s  %5d  %9d\n", stat.Language, stat.Files, stat.Tokens)
		}
		fmt.Printf("----------------  -----  ---------\n")
		fmt.Printf("%-16s  %5d  %9d\n", "Total", totalFiles, totalTokens)
	}
}

// getMimeTypes detects the MIME type of all files in the given
// directory tree using the mimetype package.   Path might be a
// directory or a file.
func getMimeTypes(path string) (mimetypes map[string]string, err error) {
	mimetypes = make(map[string]string)

	// walk the directory tree and detect MIME types
	walkFn := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("failed to access file %s: %v", path, err)
		}
		if info.IsDir() {
			return nil // skip directories
		}

		mtype, err := mimetype.DetectFile(path)
		if err != nil {
			return fmt.Errorf("failed to detect mimetype for %s: %v", path, err)
		}
		mimetypes[path] = mtype.String()
		return nil
	}

	// call walk to traverse the directory tree
	err = filepath.Walk(path, walkFn)
	if err != nil {
		return nil, fmt.Errorf("failed to walk directory %s: %v", path, err)
	}

	return mimetypes, nil
}

// getFileLanguages uses go-enry to detect programming languages for all files
// in the given directory tree, replacing the previous ohcount dependency
func getFileLanguages(root string) (map[string]string, error) {
	fileLangMap := make(map[string]string)

	walkFn := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("failed to access file %s: %v", path, err)
		}
		if info.IsDir() {
			return nil // skip directories
		}

		// Read file content for go-enry analysis
		content, err := ioutil.ReadFile(path)
		if err != nil {
			log.Printf("Failed to read file %s: %v", path, err)
			return nil // continue processing other files
		}

		// Use go-enry to detect the programming language
		// GetLanguage combines multiple detection strategies: filename, extension, content, etc.
		language := enry.GetLanguage(path, content)

		if language == "" {
			// Fall back to MIME type detection for files go-enry can't classify
			// This preserves the behavior of the original ohcount implementation
			mtype, err := mimetype.DetectFile(path)
			if err != nil {
				log.Printf("Failed to detect mimetype for %s: %v", path, err)
				return nil
			}
			if mtype.Is("text/plain") {
				language = "text/plain"
			} else {
				// Ignore non-text files (binary, etc.)
				return nil
			}
		}

		fileLangMap[path] = language
		return nil
	}

	err := filepath.Walk(root, walkFn)
	if err != nil {
		return nil, fmt.Errorf("failed to walk directory %s: %v", root, err)
	}

	return fileLangMap, nil
}

// countTokens counts the number of tokens (words) in a file
func countTokens(grok *core.Grokker, file string) (count int, err error) {
	// Open the file
	f, err := os.Open(file)
	if err != nil {
		return 0, fmt.Errorf("failed to open file %s: %v", file, err)
	}
	defer f.Close()

	// Read the file content
	buf, err := ioutil.ReadAll(f)
	if err != nil {
		return 0, fmt.Errorf("failed to read file %s: %v", file, err)
	}
	content := string(buf)
	content = strings.TrimSpace(content)

	count, err = grok.TokenCount(content)
	return
}
---FILE-END filename="/home/stevegt/lab/grokker/x/tokencount/main.go"---

<references>
[1] https://github.com/go-enry/enry
[2] https://gitlab.com/groups/gitlab-org/-/epics/8526
[3] https://github.com/go-enry/go-enry/wiki/Enry,-a-faster-implementation-of-github-linguist-in-Go
[4] https://pkg.go.dev/github.com/go-enry/go-enry/v2
[5] https://github.com/go-enry
[6] https://processwire.com/api/ref/languages/get-language/
[7] https://pkg.go.dev/github.com/go-enry/go-enry
[8] https://news.ycombinator.com/item?id=29557066
[9] https://github.com/golang/go/issues/74769
[10] https://www.geeksforgeeks.org/java/locale-getlanguage-method-in-java-with-examples/
[11] https://www.youtube.com/watch?v=1vseJiS0OfM
[12] https://www.jetbrains.com/help/go/finding-and-replacing-text-in-project.html
[13] https://pkg.go.dev/github.com/aldanial/cloc
[14] https://xojoc.pw/blog/golang-file-tree-traversal
[15] https://www.youtube.com/watch?v=akosxcqJorU
[16] https://dev.to/rezmoss/file-system-walking-with-walkdir-recursive-tree-traversal-49-dj3
[17] https://github.com/karrick/godirwalk
</references>
