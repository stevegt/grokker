---FILE-START filename="/home/stevegt/lab/grokker/x/storm/main.go"---
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"sync"

	"github.com/gofrs/flock"
	"github.com/stevegt/grokker/v3/client"
	"github.com/stevegt/grokker/v3/core"
	"github.com/yuin/goldmark"
)

var tmpl = template.Must(template.New("index").Parse(`
<html>
<head>
  <meta charset="utf-8">
  <title>Grokker LLM Chat</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
    /* Container for sidebar and main content */
    #container { display: flex; height: 100vh; }
    /* Left sidebar for Table of Contents */
    #sidebar {
      width: 250px;
      background-color: #f4f4f4;
      border-right: 1px solid #ccc;
      overflow-y: auto;
      transition: width 0.3s;
      padding: 10px;
    }
    /* Collapsed sidebar style */
    #sidebar.collapsed {
      width: 10;
      padding: 0;
      border: none;
      overflow: hidden;
    }
    /* Main content area */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #chat { padding: 20px; flex: 1; overflow-y: auto; border-bottom: 1px solid #ccc; }
    .message { margin-bottom: 10px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
    #spinner-area { padding: 10px; text-align: center; }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 10px;
      height: 10px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 5px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #input-area { background: #f0f0f0; padding: 10px; box-shadow: 0 -2px 5px rgba(0,0,0,0.1); }
    textarea { width: 60%; height: 50px; vertical-align: middle; margin-right: 10px; }
    select { vertical-align: middle; margin-right: 10px; }
    button { height: 54px; vertical-align: middle; }
    #statusBox { display: inline-block; margin-left: 10px; vertical-align: middle; font-size: 9px; }
    /* Toggle button for sidebar */
    #toggle-sidebar {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    /* Table of Contents links */
    #toc a {
      text-decoration: none;
      color: #333;
      padding: 4px;
      display: block;
    }
    #toc a:hover {
      background-color: #ddd;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <button id="toggle-sidebar">TOC</button>
      <h3>Table of Contents</h3>
      <div id="toc">
        <!-- TOC will be generated here -->
      </div>
    </div>
    <div id="main">
      <div id="chat">
        <!-- Chat messages will appear here -->
        {{.ChatHTML}}
      </div>
      <div id="spinner-area">
        <!-- Progress spinners will appear here -->
      </div>
      <div id="input-area">
        <select id="llmSelect">
          <option value="o3-mini">o3-mini</option>
          <option value="sonar-deep-research">sonar-deep-research</option>
        </select>
        <textarea id="userInput" placeholder="Enter query"></textarea>
        <button id="sendBtn">Send</button>
        <span id="statusBox">Token Count: 0</span>
        <button id="stopBtn">Stop<br>Server</button>
      </div>
    </div>
  </div>
  <script>
    // Generate a Table of Contents from headings in the chat
    function generateTOC() {
      var chat = document.getElementById("chat");
      var headings = chat.querySelectorAll("h1, h2, h3, h4, h5, h6");
      var toc = document.getElementById("toc");
      toc.innerHTML = "";
      headings.forEach(function(heading, index) {
        if (!heading.id) {
          heading.id = "heading-" + index;
        }
        var level = parseInt(heading.tagName.substring(1)); // Determine heading level from tag name
        var link = document.createElement("a");
        link.href = "#" + heading.id;
        link.textContent = heading.textContent;
        // Bold top-level links (h1)
        if(level === 1) {
          link.style.fontWeight = "bold";
        }
        // Indent based on level, e.g. 20px per sub-level
        link.style.marginLeft = ((level - 1) * 20) + "px";
        // Adjust font size based on heading level
        var fontSize = Math.max(1.2 - 0.1 * (level - 1), 0.8);
        link.style.fontSize = fontSize + "em";
        toc.appendChild(link);
      });
    }
    // Call generateTOC when the DOM content is loaded.
    document.addEventListener("DOMContentLoaded", function() {
      generateTOC();
      // Toggle sidebar visibility
      var sidebar = document.getElementById("sidebar");
      document.getElementById("toggle-sidebar").addEventListener("click", function() {
        if (sidebar.classList.contains("collapsed")) {
          sidebar.classList.remove("collapsed");
        } else {
          sidebar.classList.add("collapsed");
        }
      });
    });

    // Append a new message to the chat view without scrolling the page.
    function appendMessage(content) {
      var chat = document.getElementById("chat");
      var messageDiv = document.createElement("div");
      messageDiv.className = "message";
      messageDiv.innerHTML = content;
      // Instead of auto-scrolling or saving scroll position,
      // we simply append the content and let the browser handle it without scrolling.
      chat.appendChild(messageDiv);
      generateTOC();
    }

    // Send query to the /query endpoint.
    // Each query is immediately added to the chat with a 10px spinner and a Cancel button.
    // When the LLM response is received the spinner is removed and replaced by the response.
    function sendQuery(query, llm, selection) {
      var chat = document.getElementById("chat");
      var messageDiv = document.createElement("div");
      messageDiv.className = "message";
      if (selection === "") {
        messageDiv.innerHTML = "<strong>" + query + "</strong>";
      } else {
        messageDiv.innerHTML = "<strong>" + query + " [" + selection + "]</strong>";
      }
      // Create a spinner element next to the query.
      var spinner = document.createElement("span");
      spinner.className = "spinner";
      spinner.style.marginLeft = "10px";
      messageDiv.appendChild(spinner);
      // Create a Cancel button next to the spinner.
      var cancelBtn = document.createElement("button");
      cancelBtn.textContent = "Cancel";
      cancelBtn.style.marginLeft = "5px";
      messageDiv.appendChild(cancelBtn);
      chat.appendChild(messageDiv);
      generateTOC();

      // Create an abort controller to cancel the fetch request.
      var abortController = new AbortController();

      // When the user clicks the Cancel button, abort the request and remove the message.
      cancelBtn.addEventListener("click", function() {
        abortController.abort();
        messageDiv.remove();
        generateTOC();
      });

      fetch("/query", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        signal: abortController.signal,
        body: JSON.stringify({ query: query, llm: llm, selection: selection })
      }).then(function(response) {
        return response.json();
      }).then(function(data) {
        // Remove the spinner and cancel button once the response is received.
        spinner.remove();
        cancelBtn.remove();
        var responseDiv = document.createElement("div");
        responseDiv.innerHTML = data.response;
        // If the messageDiv is still in the document (i.e. not cancelled), append the response.
        if (document.body.contains(messageDiv)) {
          messageDiv.appendChild(responseDiv);
          updateTokenCount();
          generateTOC();
        }
      }).catch(function(err) {
        if (err.name === "AbortError") {
          return;
        }
        spinner.remove();
        cancelBtn.remove();
        var errorDiv = document.createElement("div");
        errorDiv.textContent = "Error: " + err;
        messageDiv.appendChild(errorDiv);
      });
    }

    // Poll the /tokencount endpoint to update the token count.
    function updateTokenCount() {
      fetch("/tokencount")
        .then(function(response) { return response.json(); })
        .then(function(data) {
          var statusBox = document.getElementById("statusBox");
          statusBox.textContent = "Token Count: " + data.tokens;
        })
        .catch(function(err) {
          console.error("Error fetching token count:", err);
        });
    }

    updateTokenCount(); // Initial token count fetch

    // Handle click on the Send button.
    document.getElementById("sendBtn").addEventListener("click", function() {
      var input = document.getElementById("userInput");
      var query = input.value;
      if(query.trim() === "") return;
      sendQuery(query, document.getElementById("llmSelect").value, "");
      input.value = "";
    });

    // Handle click on the Stop Server button.
    document.getElementById("stopBtn").addEventListener("click", function() {
      if(confirm("Are you sure you want to stop the server?")) {
        fetch("/stop", { method: "POST" })
          .then(function(response) {
            if(response.ok) {
              alert("Server is stopping...");
            }
          })
          .catch(function(err) {
            console.error("Error stopping server:", err);
          });
      }
    });

	/*
    // Enable selection-based querying on the chat messages.
    document.addEventListener("mouseup", function(e) {
      var selection = window.getSelection().toString().trim();
      if(selection.length > 0) {
        var input = document.getElementById("userInput");
        input.value = input.value + " " + selection;
      }
      return;
    });
	*/
  </script>
</body>
</html>
`))

// QueryRequest represents a user's query input.
type QueryRequest struct {
	Query     string `json:"query"`
	LLM       string `json:"llm"`
	Selection string `json:"selection"`
}

// QueryResponse represents the LLM's response.
type QueryResponse struct {
	Response string `json:"response"`
}

// ChatRound contains a user query and its corresponding response.
type ChatRound struct {
	Query    string
	Response string
}

// Chat encapsulates chat history and synchronization.
type Chat struct {
	mutex    sync.Mutex
	history  []*ChatRound
	filename string
}

// NewChat creates a new Chat instance using the given markdown filename.
// If the file exists, its content is loaded as the initial chat history.
func NewChat(filename string) *Chat {
	var history []*ChatRound
	if _, err := os.Stat(filename); err == nil {
		content, err := ioutil.ReadFile(filename)
		if err != nil {
			log.Printf("failed to read markdown file: %v", err)
		} else {
			// Since the file stores the chat history as markdown,
			// we load it as a single ChatMessage with an empty query.
			history = append(history, &ChatRound{Response: string(content)})
		}
	}
	return &Chat{
		history:  history,
		filename: filename,
	}
}

// updateMarkdown creates a backup of the existing markdown file and updates it with the current chat history.
func (c *Chat) _updateMarkdown() error {

	// Convert the chat history slice into markdown content.
	// We don't need getHistory to lock, since we're already holding
	// the mutex, so 'false'.
	content := c.getHistory(false)

	// Write the old content to a backup file.
	if oldContent, err := ioutil.ReadFile(c.filename); err == nil {
		backupName := c.filename + ".bak.md"
		if err := ioutil.WriteFile(backupName, oldContent, 0644); err != nil {
			log.Printf("failed to create backup: %v", err)
		}
	}

	// Write the new content to a temporary file.
	tempFile, err := ioutil.TempFile("", "storm-chat-*.md")
	if err != nil {
		log.Printf("failed to create temporary file: %v", err)
		return fmt.Errorf("failed to create temporary file: %w", err)
	}
	log.Printf("created temporary file %s", tempFile.Name())
	defer os.Remove(tempFile.Name()) // clean up temp file after writing

	if _, err := tempFile.WriteString(content); err != nil {
		log.Printf("failed to write to temporary file: %v", err)
		err = fmt.Errorf("failed to write to temporary file: %w", err)
		return err
	}
	tempFile.Close()

	// Move the temporary file to the final destination.
	if err := os.Rename(tempFile.Name(), c.filename); err != nil {
		log.Printf("failed to rename temporary file to %s: %v", c.filename, err)
		err = fmt.Errorf("failed to rename temporary file to %s: %w", c.filename, err)
		return err
	}
	log.Printf("updated markdown file %s", c.filename)

	return nil
}

// StartRound initializes a new chat round with a query and an empty response.
func (c *Chat) StartRound(query, selection string) (r *ChatRound) {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	round := &ChatRound{}

	// trim the query to avoid leading/trailing whitespace
	q := strings.TrimSpace(query)

	// add selection if provided
	if selection != "" {
		q = fmt.Sprintf("%s: [%s]", q, selection)
	}

	round.Query = q
	c.history = append(c.history, round)

	log.Printf("started chat round: %s", query)
	return round
}

// FinishRound finalizes the current chat round with a response.
func (c *Chat) FinishRound(r *ChatRound, response string) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	if r == nil {
		return fmt.Errorf("cannot finish a nil chat round")
	}

	// update the response
	r.Response = response

	err := c._updateMarkdown()
	if err != nil {
		log.Printf("error updating markdown: %v", err)
		return fmt.Errorf("error updating markdown: %w", err)
	}

	log.Printf("finished chat round: %s", r.Query)
	return nil
}

// getHistory returns the current chat history as a markdown formatted string.
func (c *Chat) getHistory(lock bool) string {
	if lock {
		c.mutex.Lock()
		defer c.mutex.Unlock()
	}
	var result string
	for _, msg := range c.history {
		// skip rounds with empty responses -- they're still pending.
		if msg.Response == "" {
			continue
		}

		if msg.Query != "" {
			result += fmt.Sprintf("\n\n**%s**\n", msg.Query)
		}
		result += fmt.Sprintf("\n\n%s\n\n---\n\n", msg.Response)
	}
	return result
}

var chat *Chat
var grok *core.Grokker
var srv *http.Server

func main() {
	port := flag.Int("port", 8080, "port to listen on")
	filePtr := flag.String("file", "", "markdown file to store chat history")
	flag.Parse()
	if *filePtr == "" {
		log.Fatal("must provide a markdown filename with -file")
	}

	var err error
	var lock *flock.Flock
	grok, _, _, _, lock, err = core.Load("", true)
	if err != nil {
		log.Fatalf("failed to load Grokker: %v", err)
	}
	defer lock.Unlock()

	chat = NewChat(*filePtr)

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Received request for %s", r.URL.Path)
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		chatContent := chat.getHistory(true)
		data := struct {
			ChatHTML template.HTML
		}{
			ChatHTML: template.HTML(markdownToHTML(chatContent)),
		}
		if err := tmpl.Execute(w, data); err != nil {
			http.Error(w, "Template error", http.StatusInternalServerError)
		}
	})

	http.HandleFunc("/query", queryHandler)
	http.HandleFunc("/tokencount", tokenCountHandler)
	http.HandleFunc("/stop", stopHandler)

	addr := fmt.Sprintf(":%d", *port)
	srv = &http.Server{Addr: addr}
	log.Printf("Starting server on %s\n", addr)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatal(err)
	}
}

// stopHandler gracefully shuts down the server when receiving a POST request.
func stopHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received stop server request: %s", r.URL.Path)
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Server stopping"))
	// Shutdown the server gracefully in a separate goroutine.
	go func() {
		if err := srv.Shutdown(context.Background()); err != nil {
			log.Printf("Error shutting down server: %v", err)
		}
	}()
}

// queryHandler processes each query, sends it to the Grokker API,
// updates the markdown file with the current chat state, and returns the LLM response as HTML.
func queryHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received query request: %s", r.URL.Path)
	if r.Method != "POST" {
		log.Printf("Method not allowed: %s", r.Method)
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req QueryRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("error decoding request body: %v", err)
		http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
		return
	}

	round := chat.StartRound(req.Query, req.Selection)
	history := chat.getHistory(false)
	// add the last N characters of the chat history as context.
	// XXX should really use embeddings and a vector db to find relevant context.
	N := 150000
	startIndex := len(history) - N
	if startIndex < 0 {
		startIndex = 0
	}
	lastN := history[startIndex:]
	lastNTokenCount, err := grok.TokenCount(lastN)
	if err != nil {
		log.Printf("Token count error: %v", err)
		lastNTokenCount = 0
	}
	log.Printf("Added %d tokens of context to query: %s", lastNTokenCount, req.Query)

	responseText := sendQueryToLLM(req.Query, req.LLM, req.Selection, lastN)

	// convert references to a bulleted list
	refIndex := strings.Index(responseText, "<references>")
	if refIndex != -1 {
		refEndIndex := strings.Index(responseText, "</references>") + len("</references>")
		// every non-blank line after <references> is a reference --
		// insert a '- ' before each line until we hit the closing tag.
		firstRefIndex := refIndex + len("<references>")
		references := strings.Split(responseText[firstRefIndex:], "\n")
		var refLines []string
		for _, line := range references {
			line = strings.TrimSpace(line)
			if line == "</references>" {
				break // stop at the closing tag
			}
			if line == "" {
				continue // skip empty lines
			}

			// if the line looks like [N] followed by a URL, convert
			// the URL to a markdown link.
			regex := `^\s*\[(\d+)\]\s*(http[s]?://\S+)\s*$`
			re := regexp.MustCompile(regex)
			m := re.FindStringSubmatch(line)
			if len(m) > 0 {
				// m[1] is the reference number, m[2] is the URL
				line = fmt.Sprintf("- [%s] [%s](%s)", m[1], m[2], m[2])
			}

			refLines = append(refLines, line)
		}
		if len(refLines) > 0 {
			// remove the original <references> section
			beforeRefs := responseText[:refIndex]
			refHead := "\n\n## References\n\n"
			afterRefs := responseText[refEndIndex:]
			responseText = beforeRefs + refHead + strings.Join(refLines, "\n") + "\n" + afterRefs
		}
	}

	// move the <think> section to the end of the response
	thinkIndex := strings.Index(responseText, "<think>")
	if thinkIndex != -1 {
		thinkEndIndex := strings.Index(responseText, "</think>") + len("</think>")
		if thinkEndIndex > thinkIndex {
			thinkSection := responseText[thinkIndex:thinkEndIndex]
			// remove the think section from the response
			responseText = responseText[:thinkIndex] + responseText[thinkEndIndex:]
			// append the think section to the end of the response
			responseText += "\n\n" + thinkSection
		} else {
			log.Printf("Malformed <think> section in response: %s", responseText)
		}
	}
	// convert <think> tags to a markdown heading
	re := strings.NewReplacer("<think>", "## Reasoning\n", "</think>", "")
	responseText = re.Replace(responseText)

	err = chat.FinishRound(round, responseText)
	if err != nil {
		http.Error(w, "Internal server error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	resp := QueryResponse{
		Response: markdownToHTML(responseText),
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

// tokenCountHandler calculates the token count for the current conversation
// using Grokker's TokenCount function and returns it as JSON.
func tokenCountHandler(w http.ResponseWriter, r *http.Request) {
	chatText := chat.getHistory(false)
	count, err := grok.TokenCount(chatText)
	if err != nil {
		log.Printf("Token count error: %v", err)
		count = 0
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]int{"tokens": count})
}

// sendQueryToLLM calls the Grokker API to obtain a markdown-formatted text.
func sendQueryToLLM(query string, llm string, selection, backgroundContext string) string {
	sysmsg := fmt.Sprintf("You are a researcher.  I will start my prompt with some context, followed by a query.  Answer the query -- don't answer other questions you might see elsewhere in the context.")

	prompt := fmt.Sprintf("---CONTEXT START---\n%s\n---CONTEXT END---\n\nNew Query: %s [%s]", backgroundContext, query, selection)

	msgs := []client.ChatMsg{
		{Role: "USER", Content: prompt},
	}

	var inputFiles []string
	var outFiles []core.FileLang

	fmt.Printf("Sending query to LLM '%s'\n", llm)
	fmt.Printf("Query: %s\n", query)
	response, _, err := grok.SendWithFiles(llm, sysmsg, msgs, inputFiles, outFiles)
	if err != nil {
		log.Printf("SendWithFiles error: %v", err)
		return fmt.Sprintf("Error sending query: %v", err)
	}
	fmt.Printf("Received response from LLM '%s'\n", llm)
	fmt.Printf("Response: %s\n", response[:10]) // print first 10 characters of response
	return response
}

// markdownToHTML converts markdown text to HTML using goldmark.
func markdownToHTML(markdown string) string {
	var buf bytes.Buffer
	if err := goldmark.Convert([]byte(markdown), &buf); err != nil {
		log.Printf("Markdown conversion error: %v", err)
		return "<p>Error rendering markdown</p>"
	}
	return buf.String()
}
---FILE-END filename="/home/stevegt/lab/grokker/x/storm/main.go"---