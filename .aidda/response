The fix turned out not to be in how you rewrite the markdown when
updating the file but in what you return to the browser. In
queryHandler you append a horizontal‐rule (an <hr> tag) to the
converted markdown. That extra <hr> is then “combined” with the
separator that comes from how chat history is written (each round is
ended with a markdown horizontal rule, which goldmark converts into
<hr>). (In the markdown file the extra <hr> isn’t there, so the
References section appears only once there.) Removing the extra hr
from the JSON response fixes the issue.

Below is the updated queryHandler: 

-----------------------------------------------------------
package main

// ... (other code remains unchanged)

func queryHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received query request: %s", r.URL.Path)
	if r.Method != "POST" {
		log.Printf("Method not allowed: %s", r.Method)
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	var req QueryRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("error decoding request body: %v", err)
		http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
		return
	}

	round := chat.StartRound(req.Query, req.Selection)
	history := chat.getHistory(false)
	// add the last TailLength characters of the chat history as context.
	// XXX should really use embeddings and a vector db to find relevant context.
	startIndex := len(history) - TailLength
	if startIndex < 0 {
		startIndex = 0
	}
	lastN := history[startIndex:]
	lastNTokenCount, err := grok.TokenCount(lastN)
	if err != nil {
		log.Printf("Token count error: %v", err)
		lastNTokenCount = 0
	}
	log.Printf("Added %d tokens of context to query: %s", lastNTokenCount, req.Query)

	responseText := sendQueryToLLM(req.Query, req.LLM, req.Selection, lastN)

	// convert references to a bulleted list
	refIndex := strings.Index(responseText, "<references>")
	if refIndex != -1 {
		refEndIndex := strings.Index(responseText, "</references>") + len("</references>")
		// every non-blank line after <references> is a reference --
		// insert a '- ' before each line until we hit the closing tag.
		firstRefIndex := refIndex + len("<references>")
		references := strings.Split(responseText[firstRefIndex:], "\n")
		var refLines []string
		for _, line := range references {
			line = strings.TrimSpace(line)
			if line == "</references>" {
				break // stop at the closing tag
			}
			if line == "" {
				continue // skip empty lines
			}

			// if the line looks like [N] followed by a URL, convert
			// the URL to a markdown link.
			regex := `^\s*\[(\d+)\]\s*(http[s]?://\S+)\s*$`
			re := regexp.MustCompile(regex)
			m := re.FindStringSubmatch(line)
			if len(m) > 0 {
				// m[1] is the reference number, m[2] is the URL
				line = fmt.Sprintf("- [%s] [%s](%s)", m[1], m[2], m[2])
			}

			refLines = append(refLines, line)
		}
		if len(refLines) > 0 {
			// replace the original <references> section with the new ## References section.
			beforeRefs := responseText[:refIndex]
			refHead := "\n\n## References\n\n"
			afterRefs := responseText[refEndIndex:]
			responseText = beforeRefs + refHead + strings.Join(refLines, "\n") + "\n" + afterRefs
		}
	}

	// move the <think> section to the end of the response
	thinkIndex := strings.Index(responseText, "<think>")
	if thinkIndex != -1 {
		thinkEndIndex := strings.Index(responseText, "</think>") + len("</think>")
		if thinkEndIndex > thinkIndex {
			thinkSection := responseText[thinkIndex:thinkEndIndex]
			// remove the think section from the response
			responseText = responseText[:thinkIndex] + responseText[thinkEndIndex:]
			// append the think section to the end of the response
			responseText += "\n\n" + thinkSection
		} else {
			log.Printf("Malformed <think> section in response: %s", responseText)
		}
	}
	// convert <think> tags to a markdown heading
	replacer := strings.NewReplacer("<think>", "## Reasoning\n", "</think>", "")
	responseText = replacer.Replace(responseText)

	err = chat.FinishRound(round, responseText)
	if err != nil {
		http.Error(w, "Internal server error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Removed extraneous <hr> so that the references section isn’t duplicated.
	resp := QueryResponse{
		Response: markdownToHTML(responseText),
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

-----------------------------------------------------------

With this change the markdown file (which is generated with one separator per round) remains unchanged and the HTML is updated with the rendered markdown once. This ensures that the References section appears only once in the browser.
